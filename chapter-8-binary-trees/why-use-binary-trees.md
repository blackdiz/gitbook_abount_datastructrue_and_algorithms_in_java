# Why Use Binary Trees?

tree 含有已排序陣列和 linked list 二者的優點，你可以像已排序陣列一樣快速找到指定的元素，同時也可以像 linked list 一樣很快地插入或刪除元素。

#### Slow Insertion in an Ordered Array

你可以用 binary search 在已排序陣列中快速找到指定的元素，假設陣列由小至大從左到右排序，先從陣列的正中間元素開始，如果比指定元素大，下次就從右半邊的中間元素開始；如果比指定元素小，下次就從左半邊的中間元素開始，這樣的時間複雜度為 O\(logN\)。此外也可以快速的遍歷整個陣列的所有元素。

但如果想插入新元素，必須先找到正確的位置，接著將該位置以右的元素全部往右移動一格來讓出空格，N 個元素的話，平均需要移動 N / 2次，刪除也是一樣，所以如果需要頻繁地插入和刪除元素，那已排序陣列就不是個好選擇。

#### Slow Searching in a Linked List

在 linked list 中插入和刪除元素相當快速，因為只要修改 node 中的參照，所以時間複雜度為 O\(1\)。

但要在 linked list 中找到指定元素就很麻煩了，必須從最前端開始遍歷直到找到該元素，平均而言，N 個元素需要檢查 N / 2 次才能找到，所以時間複雜度為 O\(N\)，雖然如果在排序演算法中 O\(N\) 是相當快的，但在資料結構的操作上卻算是慢的。即使先將 linked list 排序也於事無補，因為重點在於一定必須從最前端開始遍歷，就算是已排序後也只能這樣才可以找到指定的元素。

#### What Is a Tree?

**tree** 含有許多用 **edge** 相連的 **node** ，tree 在數學中已經被廣泛地研究，更抽象地說，tree 其實是 **graph** 的一種。

在電腦科學裡，每個 node 可能代表一個人、一台車等，也就是我們會放在資料結構中的資料。連接 node 的 edge 則表示這些 node 彼此間如何關聯，而程式可以很簡單快速地從一個 node 透過 edge 到另一個 node。事實上，從 node 到另一個 node 唯一的方法就是透過 edge 形成的路徑，而且一般而言只有從根部往下走這個方向，實作上，在 Java 中，edge 可以用參照表示。

通常在 tree 的最頂端只有一個 node，接著它底下透過 edge 連接更多的 node，而每個 node 底下同樣連接數個 node，以此類推。所以 tree 看起來會由上往下逐漸變大的樣子。

tree 有數種型態，如 **binary tree** 表示每個 node 下最多只可連接 2 個 node，而如果可連接多個 node 則稱作 **multiway tree**


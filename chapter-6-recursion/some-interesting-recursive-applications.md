# Some Interesting Recursive Applications

#### Raising a Number to a Power

假設沒有平方運算子的情形下，如何計算 2 ^ 8 ? 一個方法是用 2 \* 2 \* 2 \* 2 \* 2 \* 2 \* 2  \* 2 = 256，另一個方法是一直相乘 2 \* 2 的乘積，先從 2 \* 2 = 4，這樣就剩下 6 個 2，我們可以用剛剛算出的 4 再相乘，因為 4 包含 2 \* 2，所以 4 \* 4 = 16 等於有 4 個 2 相乘，接著 16 \* 16 = 256 就等於 8 個 2 相乘，等於 2 ^ 8。

如果用 2 乘 8 次是次方數 N 多少就要乘相同的次數，所以時間複雜度為 O\(N\)，而以乘積相乘只須要次方數 N 的 log 為 O\(logN\)。

乘積相乘的方法可以轉換成數學公式:

$$
x^2=(x^2)^y/2
$$

以  $$2^8$$ 為例，$$2 ^ 8 = (2 ^ 2) ^ (8 / 2) = (2 ^ 2) ^ 4$$。但我們不能使用平方運算子，所以即使轉換成 $$(2 ^ 2) ^ 4$$ 依然無法計算，這裡可以使用一個技巧，將 $$2 ^ 2$$ 用另一個變數取代， 假設 $$2 ^ 2 = a$$，$$(2 ^ 2) ^ 4 = a ^ 4 = (a ^ 2) ^ 2$$，然後再將 $$a ^ 2$$ 用 $$c$$ 取代，則 $$a ^ 4 = c ^ 2 = (c ^ 2) ^ 1 = c * c$$。 

如果以遞迴方式寫成程式，method 的參數為 x 、y，回傳 x ^ y，因為無法計算 x ^ y ，所以再以參數 x \* 2、y /2 遞迴呼叫，因為 x ^ y = \(x ^ 2\) ^ \(y / 2\)，直到最後變成 \(x ^ 2\) ^ \(2 / 2\) = \(x \* x\) ^ 1 就可以用相乘計算。如果用 2 ^ 8 為例，x、y的過程會是:

```text
x = 2, y = 8
x = 4, y = 4
x = 16, y = 2
x = 256, y = 1 // 開始 return
return 256, x = 256, y = 1
return 256, x = 16, y = 2
return 256, x = 4, y = 4
return 256, x = 2, y = 8
```

上述情況是在 y 可被 2 整除時，如果 y 為奇數，那我們可以在 y / 2 時只取商不管餘數 1，然後回傳時多乘一次 x 補上，比方 3 ^ 18 的話:

```text
x = 3, y = 18
x = 9, y = 9 // 此時下次呼叫時，傳入 9 / 2 = 4，不管餘數
x = 81, y = 4
x = 6561, y = 2
x = 43046721, y = 1 // 開始 return
return 43046721, x = 43046721, y = 1
return 43046721, x = 6561, y = 2
return 43046721, x = 81, y = 4
return 43046721, x = 9, y = 9 // y 為奇數，之前遞迴呼叫時少乘一次 x
                              // 所以此時多乘一次 x 補上，等 y + 1
return 43046721, x = 3, y = 18

```

#### The Knapsack Problem

背包問題相當經典，最簡單的版本是有不同重量的物品，要怎麼裝才能讓裝進背包的重量達到指定重量。

假設背包的目標重量是 20 公斤，我們分別有 11、8、7、6、5 公斤的物品可以裝，則計算的過程是:

1. 如果在過程中任何時候達到目標重量就完成任務
2. 一開始先裝入第一個物品，剩下 4 個物品必須要加總到原本目標重量減掉第一個物品的重量，這個加總數就是新的目標重量
3. 一個一個加入新的物品看有哪些組合可以符合新的目標重量，如果加總時超出目標重量就可以停止加入物品
4. 如果所有組合都達不到目標重量，就改先裝入第二個物品，用剩下 3 個物品開始重複上述步驟
5. 一直重複前述步驟直到所有的組合都嘗試過



